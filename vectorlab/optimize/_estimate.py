"""
This module provides several estimation methods to find the best
parameters for a certain algorithm.
"""

import numpy as np

from scipy import signal
from sklearn.preprocessing import MinMaxScaler

from ..utils._check import check_valid_option
from ..data._argument_generator import kwargs_expansion


def extreme_estimation(X, algorithm, method, criterion,
                       kwargs_dict, extreme_type,
                       return_criteria=False):
    r"""A simple estimation method to find out satisfied arguments.

    This is simple and rather straightforward method to find out the best
    parameters to be used in a provieded algorithm. Given a test data set
    `X` and an algorithm. We will use the provided `method` to use on dataset
    `X`. Some potential arguments should be provided, which we will generate
    all combinations across all these arguments, and criterion
    is used to judge the result of arguments choices. Extreme type should
    be fed with one of `global_min`, `local_min`, `global_max`, `local_max`
    to be searched with. Once the searching is over, it will return the
    arguments combinations that generate the result you want, and you can
    also choose to return all the criteria.

    Parameters
    ----------
    X : array_like, shape (n_samples, n_features)
        The data to be fed into the algorithm.
    algorithm : object
        The algorithm to be used.
    method : str
        The method in the algorithm to be used to fit X.
    criterion : str
        The attribute of the algorithm used to judge performance.
    kwargs_dict : dict
        The dictionary of arguments to be tested.
    extreme_type : str
        The extreme value type to search, one of global_min, local_min.
        global_max, local_max.
    return_criteria : bool, optional
        If return the whole criteria generated by combinations of
        arguments.

    Returns
    -------
    array_like, shape (n_samples)
        The combinations of arguments generated the result searched for.
    array_list, shape (n_samples)
        If return_criteria is True, a list of tuple containing
        (combination of arguments, criterion) is returned.
    """

    extreme_type = check_valid_option(
        extreme_type,
        ['global_min', 'local_min', 'global_max', 'local_max'],
        'extreme estimation type'
    )

    kwargs_list = np.array(list(kwargs_expansion(kwargs_dict)))
    criteria = np.array(
        [
            getattr(
                getattr(algorithm(**kwargs), method)(X),
                criterion
            )
            for kwargs in kwargs_list
        ]
    )

    if extreme_type == 'global_min':
        indices = [np.argmin(criteria)]
    elif extreme_type == 'local_min':
        indices = signal.argrelextrema(criteria, np.less_equal)[0]
    elif extreme_type == 'global_max':
        indices = [np.argmax(criteria)]
    elif extreme_type == 'local_max':
        indices = signal.argrelextrema(criteria, np.greater_equal)[0]

    if return_criteria:
        return kwargs_list[indices], np.array(list(zip(kwargs_list, criteria)))
    else:
        return kwargs_list[indices]


def slope_estimation(X, algorithm, method, criterion,
                     kwargs_dict, slope_type,
                     return_criteria=False):
    r"""A slope based estimation to find out satisfied arguments.

    This is slope based method to find out the best arguments to be
    used in a provided algorithm. Given a test data set `X` and an
    algorithm. We will use the provided `method` to use on
    dataset `X`. Some potential arguments should be provided, which we
    will generate all combinations across all these arguments, and
    criterion is used to judge the result of arguments choices. Slope
    type should be fed with one of `ascending` and `descending` to be
    searched with. If the slope type is ascending, we try to find the
    point from which the following criteria increase in a linear fashion.
    When the slope type is descending, we try to find th point from which
    the following criteria decrease in a linear fashion. Once the searching
    is over, it will return the arguments combinations that generate the
    result you want, and you can also choose to return all the criteria.

    Parameters
    ----------
    X : array_like, shape (n_samples, n_features)
        The data to be fed into the algorithm.
    algorithm : object
        The algorithm to be used.
    method : str
        The method in the algorithm to be used to fit X.
    criterion : str
        The attribute of the algorithm used to judge performance.
    kwargs_dict : dict
        The dictionary of arguments to be tested.
    slope_type : str
        The slope type to search, one of ascending or descending.
    return_criteria : bool, optional
        If return the whole criteria generated by combinations of
        arguments.

    Returns
    -------
    array_like, shape (n_samples)
        The combinations of arguments generated the result searched for.
    list
        If return_criteria is True, a list of tuple containing
        (combination of arguments, criterion) is returned.
    """

    slope_type = check_valid_option(
        slope_type,
        ['ascending', 'descending'],
        'slope estimation type'
    )

    kwargs_list = np.array(list(kwargs_expansion(kwargs_dict)))
    criteria = np.array(
        [
            getattr(
                getattr(algorithm(**kwargs), method)(X),
                criterion
            )
            for kwargs in kwargs_list
        ]
    )

    # Fake a linear array
    normalized_x = MinMaxScaler().fit_transform(
        np.arange(criteria.shape[0]).reshape(-1, 1)
    ).ravel()
    normalized_criteria = MinMaxScaler().fit_transform(
        criteria.reshape(-1, 1)
    ).ravel()

    if slope_type == 'ascending':
        indices = signal.argrelextrema(
            normalized_criteria - normalized_x, np.greater_equal
        )[0]
    elif slope_type == 'descending':
        indices = signal.argrelextrema(
            normalized_criteria - np.flip(normalized_x), np.less_equal
        )[0]

    if return_criteria:
        return kwargs_list[indices], np.array(list(zip(kwargs_list, criteria)))
    else:
        return kwargs_list[indices]
